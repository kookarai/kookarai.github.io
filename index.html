<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Record and Send Audio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.7.16"></script>
</head>

<body class="bg-gray-900 flex flex-col items-center justify-center min-h-screen p-4">
<div id="app" class="bg-gray-800 shadow-xl rounded-2xl p-8 w-full max-w-md">
    <div class="flex justify-between mb-6">
        <button @click="startRecording" :disabled="isRecording"
                class="bg-green-500 hover:bg-green-600 text-white py-3 px-4 rounded-lg transition ease-in-out transform hover:scale-105">
            Record
        </button>
        <button @click="stopRecording" :disabled="!isRecording"
                class="bg-red-500 hover:bg-red-600 text-white py-3 px-4 rounded-lg transition ease-in-out transform hover:scale-105">
            Stop
        </button>
    </div>

    <p class="text-gray-400 text-center mb-6">{{ status }}</p>

    <audio v-if="audioSrc" :src="audioSrc" class="w-full mb-6 rounded-lg" controls></audio>

    <input v-model="phoneNumber" type="tel" class="w-full py-2 px-4 bg-gray-700 text-white rounded-lg mb-6"
           placeholder="Phone Number">

    <input v-model="datetime" type="text" id="datetime" class="w-full py-2 px-4 bg-gray-700 text-white rounded-lg mb-6"
           placeholder="Choose date and time">

    <button @style="" @click="scheduleEvent" :disabled="!canSchedule || !audioSrc"
            class="w-full bg-blue-500 hover:bg-blue-600 text-white py-3 px-4 rounded-lg">
        Schedule
    </button>

    <div v-if="scheduledEvents.length" class="mt-8">
        <h2 class="text-white mb-4 text-lg font-semibold">Scheduled Events</h2>
        <ul class="bg-gray-700 p-4 rounded-lg">
            <li v-for="(event, index) in scheduledEvents" :key="index"
                class="flex justify-between items-center mb-2 text-white">
                <div>
                    <p class="text-sm">{{ event.datetime }}</p>
                    <p class="text-xs text-gray-400">Phone: {{ event.phoneNumber }}</p>
                </div>
                <button @click="deleteScheduledEvent(event.id)"
                        class="bg-red-500 hover:bg-red-600 text-white py-1 px-3 rounded-lg">
                    Delete
                </button>
            </li>
        </ul>
    </div>
</div>

<script>
    window.addEventListener("message", function (event) {
        if (!isJSONValid(event.data)) {
            return;
        }

        const eventData = JSON.parse(event.data);
    });
    let mainApp = new Vue({
        el: '#app',
        data: {
            status: 'Not recording...',
            isRecording: false,
            audioChunks: [],
            mediaRecorder: null,
            audioSrc: null,
            datetime: '',
            phoneNumber: '918073756411',
            modelID: "eleven_multilingual_sts_v2",
            voiceID: "DJDkcaY4POaxra3iaZ5b",
            apiKey: "sk_3b1e7773ad665bd2d039e2a2fdb987c214c1cf07ac63124b",
            supabaseUrl: 'https://oqhygqxpxpdjtvaahwxk.supabase.co',
            supabaseKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9xaHlncXhweHBkanR2YWFod3hrIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTcyNTYxNTY5MSwiZXhwIjoyMDQxMTkxNjkxfQ.oYECwS4Y6ymOwGuXOVKh0lIWQVlgnbDOlDCfYY1AUVk',
            audioURL: null,
            scheduledEvents: [],
            voiceSettings: {
                stability: 0.5,
                similarity_boost: 0.75,
                style: 0.0,
                use_speaker_boost: true
            }
        },
        computed: {
            canSchedule() {
                return this.audioURL && this.datetime && /^\d{10,15}$/.test(this.phoneNumber);
            }
        },
        methods: {
            async deleteScheduledEvent(eventId) {
                try {
                    const response = await fetch('https://intent-kit-16.hasura.app/v1/metadata', {
                        method: 'POST',
                        headers: {
                            'content-type': 'application/json',
                            'x-hasura-admin-secret': '32qR4KmXOIpsGPQKMqEJHGJS27G5s7HdSKO3gdtQd2kv5e852SiYwWNfxkZOBuQ6'
                        },
                        body: JSON.stringify({
                            type: "delete_scheduled_event",
                            args: {
                                type: "one_off",
                                event_id: eventId
                            }
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log(`Event ${eventId} deleted successfully`, data);
                    this.getScheduledEvents();
                    return data;
                } catch (error) {
                    console.error(`Error deleting event ${eventId}:`, error);
                }
            },
            async getScheduledEvents() {
                try {
                    const response = await fetch('https://intent-kit-16.hasura.app/v1/metadata', {
                        method: 'POST',
                        headers: {
                            'content-type': 'application/json',
                            'x-hasura-admin-secret': '32qR4KmXOIpsGPQKMqEJHGJS27G5s7HdSKO3gdtQd2kv5e852SiYwWNfxkZOBuQ6'
                        },
                        body: JSON.stringify({
                            type: "get_scheduled_events",
                            args: {type: "one_off", status: ["scheduled"], limit: 1001}
                        })
                    });
                    const data = await response.json();
                    this.scheduledEvents = data.events.map(event => ({
                        datetime: event.scheduled_time,
                        phoneNumber: event.payload.number,
                        id: event.id
                    }));
                } catch (error) {
                    console.error('Error fetching events:', error);
                }
            },
            startRecording() {
                this.audioSrc = null;
                navigator.mediaDevices.getUserMedia({audio: true}).then(stream => {
                    this.mediaRecorder = new MediaRecorder(stream);
                    this.mediaRecorder.start();
                    this.status = "Recording...";
                    this.isRecording = true;
                    this.mediaRecorder.ondataavailable = event => this.audioChunks.push(event.data);
                }).catch(() => alert("Mic access denied"));
            },
            stopRecording() {
                this.mediaRecorder.stop();
                this.mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(this.audioChunks, {type: "audio/webm"});
                    this.audioChunks = [];
                    this.processAudio(audioBlob);
                };
                this.isRecording = false;
                this.status = "Recording stopped.";
            },
            processAudio(audioBlob) {
                const form = new FormData();
                form.append("model_id", this.modelID);
                form.append("voice_settings", JSON.stringify(this.voiceSettings));
                form.append("audio", audioBlob);

                fetch(`https://api.elevenlabs.io/v1/speech-to-speech/${this.voiceID}`, {
                    method: "POST",
                    headers: {"xi-api-key": this.apiKey},
                    body: form
                })
                    .then(response => response.blob())
                    .then(blob => {
                        this.uploadAudio(blob);
                        this.audioSrc = URL.createObjectURL(blob);
                        this.status = "Audio processed.";
                    })
                    .catch(() => this.status = "Error processing audio.");
            },
            uploadAudio(audioBlob) {
                const fileName = `audio-${Date.now()}.wav`;
                const formData = new FormData();
                formData.append('file', audioBlob, fileName);

                fetch(`${this.supabaseUrl}/storage/v1/object/audio/${fileName}`, {
                    method: 'POST',
                    headers: {'Authorization': `Bearer ${this.supabaseKey}`, 'apikey': this.supabaseKey},
                    body: formData
                })
                    .then(response => {
                        if (response.ok) this.audioURL = `${this.supabaseUrl}/storage/v1/object/public/audio/${fileName}`;
                    })
                    .catch(() => alert("Error uploading audio."));
            },
            scheduleEvent() {
                const payload = {url: this.audioURL, number: this.phoneNumber};
                const scheduleAt = moment(this.datetime).utc().format();

                fetch('https://intent-kit-16.hasura.app/v1/metadata', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Hasura-Role': 'admin',
                        'x-hasura-admin-secret': '32qR4KmXOIpsGPQKMqEJHGJS27G5s7HdSKO3gdtQd2kv5e852SiYwWNfxkZOBuQ6'
                    },
                    body: JSON.stringify({
                        type: "create_scheduled_event",
                        args: {
                            webhook: "https://kookarai.grow90.org/sendMessage",
                            schedule_at: scheduleAt,
                            payload
                        }
                    })
                })
                    .then(() => {
                        this.status = `Event scheduled at ${moment(this.datetime).format('YYYY-MM-DD HH:mm:ss')}.`;
                        this.getScheduledEvents();
                    })
                    .catch(() => this.status = "Error scheduling event.");
            }
        },
        mounted() {
            this.getScheduledEvents();
            flatpickr("#datetime", {
                enableTime: true,
                dateFormat: "Y-m-d H:i",
                minDate: new Date(Date.now() + 60000),
                defaultDate: new Date(Date.now() + 60000)
            });
        }
    });
</script>

</body>
</html>
